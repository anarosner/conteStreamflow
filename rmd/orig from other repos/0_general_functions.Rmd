
```{r functions to label each daily records with date representing season/month/year}

library(lubridate)

to.season<-function(d,return.type="date") {           #,out.fmt="seasons"
     x<-data.frame(date=d,year=year(d),month=month(d))  # ,season=time2season(d,out.fmt=out.fmt))  
     
     x[x$month>=12,"year"]<-x[x$month>=12,"year"]+1
#      x$season.num<-sapply(x$season, function(x) {if(x=="autumn") 1
#                                                  else if (x=="winter") 2
#                                                  else if (x=="spring") 3
#                                                  else if (x=="summer") 4 })
     x[,c("season.date","season")]<-matrix(unlist(
          lapply(x$month, function(y) {
               if(y %in% 9:11) c("11/28","fall")
               else if (y %in% c(12,1:2)) c("2/28","winter")
               else if (y %in% 3:5) c("5/28","spring") 
               else if (y %in% 6:8) c("8/28","summer")})),ncol=2,byrow=T)
     x$season.date<-as.Date(paste0(x$year,"/",x$season.date))
     if (return.type=="date")
          return(x[,"season.date"])  
     else if (return.type=="season")
          return(x[,"season"])  
     else
          return(as.data.frame(x[,c("season","season.date","year")]) )  
}
to.water.year<-function(d,date.only=T) {
     x<-data.frame(date=d,year=year(d),month=month(d))
     x[x$month>=10,"year"]<-x[x$month>=10,"year"]+1
     x$water.date<-as.Date(paste0(x$year,"/9/30"))
     if (!date.only)
          return(as.data.frame(x[,c("year","water.date")]))
     else
          return(x[,"water.date"])
}
to.month<-function(d) {
     return(month.date<-as.Date(paste0(year(d),"/",month(d),"/1")))
}

```


```{r }
library(reshape2)


melt.3d<-function(a) {
#      out<-melt(a[,,1])
#      names(out)<-c("date","site_no",dimnames(a)[[3]][1])
#      
     x<-data.frame(id=1:dim(a)[[2]],site_no=dimnames(a)[[2]],stringsAsFactors=F)
     dimnames(a)[[2]]<-x$id
     out<-melt(a[,,1])
     names(out)<-c("date","id",dimnames(a)[[3]][1])
     out<-merge(out,x,by="id",sort=F)
     out<-out[,c("date","site_no",dimnames(a)[[3]][1])]
     for (i in 2:dim(a)[3]) {
          m<-melt(a[,,i])
          out[,dimnames(a)[[3]][i]]<-m[,3]
     }
     return(out)     
}
```


```{r goodness of fit/validation functions}

library(topmodel)
library(USGSwsStats)

CV.error<-function(obs,pred) {
     sd(pred-obs)/mean(obs)
}
bias<-function(obs,pred) {
     b<-mean(pred)-mean(obs)
     return(list(bias=b,percent.bias=b/mean(obs)*100))
}
goodness<-function(df=NULL,obs=NULL,pred=NULL) {
     if(is.null(obs) | is.null(pred)){
          if(is.null(df)){
               print("ERROR: must define obs and pred vectors, 
                     or data frame w/ obs and pred columns")
               return(NULL)
          }
          else{
               obs<-df$obs
               pred<-df$pred
               }
     }
     f<-data.frame(sample.n=length(obs),mean=mean(obs))
     f$RMSE<-rmse(obs,pred)
     f$NSEff<-NSeff(obs,pred)
     f$bias<-mean(pred)-mean(obs)
     f$percent.bias<-(mean(pred)-mean(obs))/mean(obs)*100
     f$pearsonR<-cor(obs,pred,method="pearson")
     f$CV.error<-sd(pred-obs)/mean(obs)
     return(round(f,3))
}

```

```{r nonzero function for log values ~0 }
non.zero<-function(x) {
     vapply(x,FUN.VALUE=1,FUN=function(x1) {
          if (is.na(x1) || is.nan(x1) || x1<=0)  
               return(10^-6)
          else return(x1)
     })
}
```

```{r}
# function for pearson correlation 
# adapted, with some alterations, from (http://www2.warwick.ac.uk/fac/sci/moac/people/students/peter_cock/r/iris_plots/)
panel.pearson <- function(x, y, ...) {
  horizontal <- (par("usr")[1] + par("usr")[2]) / 2; 
  vertical <- (par("usr")[3] + par("usr")[4]) / 2; 
  col<-rep("black",length(cor(x,y)))
  col[abs(cor(x,y))>=.5]<-"red"
  text(horizontal, vertical, format(cor(x,y), digits=2),col=col)

}

## Scatterplot Matrices
## put histograms on the diagonal
panel.hist <- function(x, ...) {
  usr <- par("usr"); on.exit(par(usr))
  par(usr = c(usr[1:2], 0, 1.5) )
  h <- hist(x, plot = FALSE)
  breaks <- h$breaks; nB <- length(breaks)
  y <- h$counts; y <- y/max(y)
  rect(breaks[-nB], 0, breaks[-1], y, col="gray", ...)
  }

panel.cor <- function(x, y, method = "pearson", use = "pairwise.complete.obs", digits = 2, prefix="", cex.cor) {
  usr <- par("usr"); on.exit(par(usr))
  par(usr = c(0, 1, 0, 1))
  x = x
  y = y
  Cor <- switch(method,
                spearman = cor(x, y, method = "spearman", use = use),
                pearson = cor(x, y, method = "pearson", use = use),
                kendell = cor(x, y, method = "kendall", use = use),
                stop("\nThe type of correlation must be spearman, pearson, or kendall\n"))
  txt <- format(c(Cor, 0.123456789), digits = digits)[1]
  txt <- paste(prefix, txt, sep="")
  #if(missing(cex.cor)) cex <- 0.9/strwidth(txt)
  text(0.5, 0.5, txt, cex = 1.5)
  #text(0.9, 0.9, Cor.Type, cex = 1)
}

panel.smooth <- function (x, y, col = par("col"), bg = NA, pch = par("pch"), 
    cex = 1, col.smooth = "red", span = 2/3, iter = 3, ...) {
  x <- sample(x = x, size=1000, replace = F)
  y <- sample(x = y, size = 1000, replace = F)
    #x <- rnorm(500, mean(x, na.rm = T), sd(x, na.rm = T)) # alpha bleeding
    #y <- rnorm(500, mean(y, na.rm = T), sd(y, na.rm = T)) # alpha bleeding
    points(x, y, pch = pch, col = col, bg = bg, cex = cex)
    ok <- is.finite(x) & is.finite(y)
    if (any(ok)) 
        lines(stats::lowess(x[ok], y[ok], f = span, iter = iter), 
            col = col.smooth, ...)
}

```

